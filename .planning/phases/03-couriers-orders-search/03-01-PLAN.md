# Plan 03-01: Order Feature Module (Types, API, Queries, List Page)

## Context

Phase 3 adds order and courier entity coverage plus global search. Orders are the most data-rich entity in the system — they reference users, retailers, couriers, items, payments, and delivery details. The backend provides two admin order endpoints: `GET /admin/vendors/:vendorId/orders` (per-vendor) and `GET /admin/users/:userId/orders` (per-user), but no `GET /admin/orders` (all orders). We need to aggregate orders across all vendors to build a global order list.

**Backend constraint:** There is no single "all orders" admin endpoint. The practical approach is to use the retailer orders endpoint for the existing per-vendor views we already have, and add a new aggregation approach for the global order list. Since the backend is out of scope for changes, the order list page will initially load orders by requiring the admin to select or search for a vendor/user first, OR we fetch all vendors and aggregate their orders. Given the small marketplace scale (few vendors), fetching all vendor orders in parallel is acceptable.

**Courier constraint:** Couriers are third-party (Stuart API) — no standalone entity exists. Courier data is embedded in each order's `deliveryDetails` JSONB. The "Couriers" page will be deferred to Plan 03-02 as an order-delivery-focused view rather than a standalone entity.

## Dependencies

- Phase 02-01: DataTable, DataTableColumnHeader, EntityDetailHeader, CopyableField, useTableParams
- Phase 01-03: API client (`api.get`, `api.getRaw`)
- Phase 02-03: RetailerOrdersTab pattern (reference for order data shape)

## Requirements Addressed

- LIST-04: Paginated order list with sortable columns
- LIST-05 (partial): Status filter on order list

## Tasks

### Task 1: Create order types and transforms

**Create `src/features/orders/types.ts`:**

```typescript
// Backend shape from /admin/vendors/:id/orders
export interface BackendOrder {
  id: string;
  orderId: string;               // ST-XXXXX display ID
  customerId: string | null;
  customerName: string | null;
  customerEmail?: string | null;
  status: string;
  totalAmount: number | null;
  subtotal?: number | null;
  createdAt: string;
  updatedAt?: string;
  items: BackendOrderItem[];
  // Fields from findOrderByOrderIdWithRelations
  user?: { id: string; firstName: string; lastName: string; email: string; phone: string } | null;
  vendor?: { id: string; storeName: string; logo?: string } | null;
  deliveryDetails?: Record<string, unknown> | null;
  shippingAddress?: Record<string, unknown> | null;
  paymentStatus?: string | null;
  paymentMethod?: string | null;
  pricingBreakdown?: Record<string, unknown> | null;
  payments?: BackendPayment[] | null;
  stuartJobId?: string | null;
}

export interface BackendOrderItem {
  id?: string;
  productId: string;
  variantId: string;
  quantity: number;
  price: number;
  totalPrice: number;
  metadata?: Record<string, unknown> | null;
}

export interface BackendPayment {
  id: string;
  status: string;
  provider: string;
  providerPaymentId?: string;
  amount: number;
  currency: string;
  refundedAmount?: number | null;
}

export interface OrderViewModel {
  id: string;
  orderId: string;               // ST-XXXXX display format
  customerName: string;
  customerEmail: string;
  status: string;
  totalAmount: string;           // Formatted currency string
  totalAmountRaw: number | null; // Raw for sorting
  itemCount: number;
  createdAt: string;
  // Enriched fields for detail view
  retailerName?: string;
  retailerId?: string;
  userId?: string;
  paymentStatus?: string;
}

export function toOrderViewModel(backend: BackendOrder): OrderViewModel {
  const name = backend.customerName
    ?? (backend.user ? `${backend.user.firstName} ${backend.user.lastName}`.trim() : "Unknown");
  const email = backend.customerEmail ?? backend.user?.email ?? "No email";

  return {
    id: backend.id,
    orderId: backend.orderId ?? backend.id.slice(0, 8),
    customerName: name,
    customerEmail: email,
    status: backend.status?.toLowerCase() ?? "unknown",
    totalAmount: formatGBP(backend.totalAmount),
    totalAmountRaw: backend.totalAmount,
    itemCount: backend.items?.length ?? 0,
    createdAt: backend.createdAt,
    retailerName: backend.vendor?.storeName,
    retailerId: backend.vendor?.id,
    userId: backend.user?.id ?? backend.customerId ?? undefined,
    paymentStatus: backend.paymentStatus?.toLowerCase(),
  };
}

function formatGBP(amountPence: number | null): string {
  if (amountPence == null) return "--";
  return new Intl.NumberFormat("en-GB", {
    style: "currency",
    currency: "GBP",
  }).format(amountPence / 100);
}
```

### Task 2: Create order API functions

**Create `src/features/orders/api/order-api.ts`:**

```typescript
export interface GetOrdersByVendorParams {
  vendorId: string;
  page?: number;
  limit?: number;
}

export interface GetOrdersByUserParams {
  userId: string;
  page?: number;
  limit?: number;
}

// Fetch orders for a specific vendor (admin endpoint)
export async function getOrdersByVendor(params: GetOrdersByVendorParams) {
  const search = new URLSearchParams();
  if (params.page) search.set("page", String(params.page));
  if (params.limit) search.set("limit", String(params.limit));
  const qs = search.toString();
  return api.getRaw<BackendOrder[]>(
    `admin/vendors/${params.vendorId}/orders${qs ? `?${qs}` : ""}`
  );
}

// Fetch orders for a specific user (admin endpoint)
export async function getOrdersByUser(params: GetOrdersByUserParams) {
  const search = new URLSearchParams();
  if (params.page) search.set("page", String(params.page));
  if (params.limit) search.set("limit", String(params.limit));
  const qs = search.toString();
  return api.getRaw<BackendOrder[]>(
    `admin/users/${params.userId}/orders${qs ? `?${qs}` : ""}`
  );
}

// Fetch all vendors (to aggregate orders across all vendors)
// Reuses existing retailer API
export { getRetailers } from "@/features/retailers/api/retailer-api";
```

### Task 3: Create order query hooks

**Create `src/features/orders/api/order-queries.ts`:**

```typescript
export const orderKeys = {
  all: ["orders"] as const,
  lists: () => [...orderKeys.all, "list"] as const,
  listByVendor: (vendorId: string, params: object) =>
    [...orderKeys.lists(), "vendor", vendorId, params] as const,
  listByUser: (userId: string, params: object) =>
    [...orderKeys.lists(), "user", userId, params] as const,
  details: () => [...orderKeys.all, "detail"] as const,
  detail: (orderId: string) => [...orderKeys.details(), orderId] as const,
};

// Hook for vendor-scoped orders
export function useVendorOrdersQuery(vendorId: string, params) { ... }

// Hook for user-scoped orders
export function useUserOrdersQuery(userId: string, params) { ... }
```

Note: The existing `useUserOrdersQuery` in user-queries.ts and `useRetailerOrdersQuery` in retailer-queries.ts fetch orders for entity detail tabs. The new hooks here are for the standalone orders list page and accept pagination params.

### Task 4: Create OrderListPage

**Create `src/features/orders/components/OrderListPage.tsx`:**

Page layout:
- PageHeader: "Orders" / "Track and manage orders"
- Filter bar: Search input (by order ID, customer name) + Status dropdown + Vendor dropdown
- DataTable with columns: Order ID (copyable, mono), Customer, Retailer, Status (badge), Total, Date
- Clicking an order navigates to `/orders/$orderId`

**Approach for listing all orders:**
Since there's no global orders endpoint, the page will:
1. Default to showing a vendor selector — admin picks a vendor to see their orders
2. Alternatively, show all orders by fetching vendors list first, then orders for the selected (or first) vendor
3. Use the same DataTable + pagination pattern as UserListPage/RetailerListPage

Columns:
```typescript
const columns: ColumnDef<OrderViewModel>[] = [
  { accessorKey: "orderId", header: "Order ID" },        // mono, copyable
  { accessorKey: "customerName", header: "Customer" },    // link to user detail
  { accessorKey: "retailerName", header: "Retailer" },    // from vendor relation
  { accessorKey: "status", header: "Status" },            // StatusBadge
  { accessorKey: "totalAmount", header: "Total" },        // formatted GBP
  { accessorKey: "createdAt", header: "Date" },           // formatted date
];
```

### Task 5: Create order list route

**Update `src/app/routes/_authenticated/orders/index.tsx`:**

Replace placeholder with:
```typescript
import { createFileRoute } from "@tanstack/react-router";
import { OrderListPage } from "@/features/orders/components/OrderListPage";

export const Route = createFileRoute("/_authenticated/orders/")({
  component: OrderListPage,
});
```

## Commit

Single commit: `feat(03-01): order feature module with types, API, queries, and list page`

## Success Criteria

- [ ] Order types with Backend → ViewModel transform exist
- [ ] Order API functions use admin vendor/user order endpoints
- [ ] OrderListPage renders with DataTable, pagination, status filter, and vendor selector
- [ ] Clicking an order row prepares navigation to order detail (route exists even if detail page is placeholder)
- [ ] `npm run build` passes with no TypeScript errors
