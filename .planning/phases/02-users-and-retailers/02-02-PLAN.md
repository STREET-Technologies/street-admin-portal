# Plan 02-02: User Feature — Types, API, List Page, Detail Page

## Context

Complete vertical slice for the user entity. Uses shared components from Plan 02-01 (DataTable, EntityDetailHeader, CopyableField, useTableParams). Backend endpoints documented via research.

## Dependencies

- Plan 02-01: DataTable, DataTableColumnHeader, EntityDetailHeader, CopyableField, useTableParams
- Phase 01-03: API client, API error handling

## Requirements Addressed

- LIST-01: Paginated user list with sortable columns
- LIST-05 (user portion): Filter by status and date range
- LIST-06 (user portion): Server-side pagination
- DETL-01: Full-page user detail with tabs (Overview, Orders, Addresses, Devices, Notes)
- DETL-05 (user portion): Status badges on user entities
- DETL-06 (user portion): Copyable IDs, emails, phone numbers

## Backend Endpoints

- `GET /admin/users` — params: search, page, limit → `PaginatedResponse<BackendUser>`
- `GET /admin/users/:userId` — returns user detail
- `GET /admin/users/:userId/addresses` — returns address list
- `GET /admin/users/:userId/orders` — returns order list
- `GET /admin/users/:userId/devices` — returns device list

**Known:** No user status field from backend (all users are effectively "active"). No sorting params on backend — sort client-side within page for now, document as limitation.

## Tasks

### Task 1: Create user types

**Create `src/features/users/types.ts`:**

```typescript
// Backend shape (what API returns)
interface BackendUser {
  id: string;
  firstName: string | null;
  lastName: string | null;
  email: string | null;
  phone: string | null;
  profileImage: string | null;
  language: string | null;
  role: string;
  ssoProvider: string | null;
  isTestAccount: boolean;
  isAnonymized: boolean;
  createdAt: string;
  updatedAt: string;
}

// Frontend view model (what components consume)
interface UserViewModel {
  id: string;
  name: string;           // computed: firstName + lastName, fallback "Unknown"
  email: string;           // fallback "No email"
  phone: string;           // fallback "No phone"
  status: EntityStatus;    // derived: "active" (backend has no status field)
  avatarUrl: string | null;
  isTestAccount: boolean;
  createdAt: string;
  updatedAt: string;
}

// Transform function
function toUserViewModel(backend: BackendUser): UserViewModel
```

Also: `BackendUserAddress`, `BackendUserDevice` interfaces based on backend response shapes.

### Task 2: Create user API layer + query hooks

**Create `src/features/users/api/user-api.ts`:**
- `getUsers(params: { search?: string; page?: number; limit?: number })` → `PaginatedResponse<BackendUser>`
- `getUser(userId: string)` → `BackendUser`
- `getUserAddresses(userId: string)` → `BackendUserAddress[]`
- `getUserOrders(userId: string)` → order list
- `getUserDevices(userId: string)` → `BackendUserDevice[]`

**Create `src/features/users/api/user-queries.ts`:**
Query key factory + TanStack Query hooks:
- `userKeys.all`, `userKeys.lists()`, `userKeys.list(params)`, `userKeys.details()`, `userKeys.detail(id)`
- `useUsersQuery(params)` — list with pagination meta
- `useUserQuery(userId)` — single user detail
- `useUserAddressesQuery(userId)` — addresses
- `useUserOrdersQuery(userId)` — orders
- `useUserDevicesQuery(userId)` — devices

All hooks apply `toUserViewModel` transform in the `select` option where applicable.

### Task 3: Create user list page

**Create `src/features/users/components/UserListPage.tsx`:**

- PageHeader: "Users" with description "Manage user accounts"
- Search input (debounced 300ms) that maps to `search` API param
- DataTable with columns: Name (avatar + name), Email, Phone, Status, Created, Actions
- Name column: avatar thumbnail + full name, clickable → navigates to `/users/$userId`
- Email/Phone columns: show with CopyButton on hover
- Status column: StatusBadge
- Created column: formatted date
- Pagination: server-side via useTableParams

**Update `src/app/routes/_authenticated/users/index.tsx`:**
Replace placeholder with `<UserListPage />`.

### Task 4: Create user detail page with tabs

**Create route: `src/app/routes/_authenticated/users/$userId.tsx`:**
- File-based route for `/users/:userId`
- Loads user detail, renders UserDetailPage

**Create `src/features/users/components/UserDetailPage.tsx`:**
- EntityDetailHeader with user name, email, avatar, status
- Tabs: Overview | Orders | Addresses | Devices | Notes
- Each tab is a separate component (below)

**Create tab components:**
- `UserOverviewTab.tsx` — Card grid: Contact Info (email, phone with CopyableField), Account Details (ID with CopyableField, role, SSO provider, created/updated dates, test account badge)
- `UserOrdersTab.tsx` — Mini DataTable of user's orders (ID, retailer, status, total, date). Empty state if none.
- `UserAddressesTab.tsx` — Card list of addresses. Empty state if none.
- `UserDevicesTab.tsx` — Card list of devices (platform, model, OS version, app version). Empty state if none.
- `UserNotesTab.tsx` — Placeholder with EmptyState ("Notes will be available in Phase 4")

### Task 5: Wire up route and verify build

- Ensure `$userId.tsx` route is picked up by TanStack Router's auto-generation
- Run `npm run build` to verify no TypeScript errors
- Verify route tree includes both `/users/` and `/users/$userId`

## Commits

Single commit: `feat(02-02): user list page, detail page with tabs, API layer`

## Success Criteria

- [ ] User list page shows paginated DataTable with search
- [ ] Clicking a user row navigates to `/users/:userId`
- [ ] User detail page shows EntityDetailHeader + 5 tabs
- [ ] Overview tab shows user info with copyable fields
- [ ] Orders/Addresses/Devices tabs show data or empty states
- [ ] Notes tab shows Phase 4 placeholder
- [ ] All types are strict (no `any`, no `as any`)
- [ ] `npm run build` passes
