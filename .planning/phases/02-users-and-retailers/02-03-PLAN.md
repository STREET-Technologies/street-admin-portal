# Plan 02-03: Retailer Feature — Types, API, List Page, Detail Page

## Context

Complete vertical slice for the retailer entity. Parallel with Plan 02-02 (users). Same shared components, same patterns, different data shape. Backend uses "vendor" terminology — frontend transforms to "retailer" for user-facing labels.

## Dependencies

- Plan 02-01: DataTable, DataTableColumnHeader, EntityDetailHeader, CopyableField, useTableParams
- Phase 01-03: API client, API error handling

## Requirements Addressed

- LIST-02: Paginated retailer list with sortable columns
- LIST-05 (retailer portion): Filter by status and date range
- LIST-06 (retailer portion): Server-side pagination
- DETL-02: Full-page retailer detail with tabs (Overview, Orders, Notes)
- DETL-05 (retailer portion): Status badges on retailer entities
- DETL-06 (retailer portion): Copyable IDs, emails, phone numbers

## Backend Endpoints

- `GET /admin/vendors` — params: name, vendorCategory, page, limit → `PaginatedResponse<BackendVendor>`
- `GET /admin/vendors/:vendorId` — returns vendor detail
- `GET /admin/vendors/:vendorId/orders` — returns order list

**Note:** Backend says "vendor", frontend says "retailer". Transform layer handles this.

## Tasks

### Task 1: Create retailer types

**Create `src/features/retailers/types.ts`:**

```typescript
// Backend shape (what API returns — uses "vendor" naming)
interface BackendVendor {
  id: string;
  storeName: string;
  storeUrl: string | null;
  logo: string | null;
  description: string | null;
  vendorType: string | null;
  email: string | null;
  phone: string | null;
  address: string | null;
  vendorCategory: string | null;
  commissionPercentage: number | null;
  isOnline: boolean;
  isActive: boolean;
  stripeAccountId: string | null;
  openingHours: Record<string, unknown> | null;
  createdAt: string;
  updatedAt: string;
}

// Frontend view model
interface RetailerViewModel {
  id: string;
  name: string;            // from storeName
  email: string;
  phone: string;
  status: EntityStatus;    // derived from isActive + isOnline
  category: string;
  logoUrl: string | null;
  commissionPercentage: number | null;
  storeUrl: string | null;
  address: string;
  createdAt: string;
  updatedAt: string;
}

// Transform function
function toRetailerViewModel(backend: BackendVendor): RetailerViewModel
```

Status derivation: `isActive && isOnline` → "active", `isActive && !isOnline` → "inactive", `!isActive` → "blocked"

### Task 2: Create retailer API layer + query hooks

**Create `src/features/retailers/api/retailer-api.ts`:**
- `getRetailers(params: { name?: string; vendorCategory?: string; page?: number; limit?: number })` → `PaginatedResponse<BackendVendor>`
- `getRetailer(retailerId: string)` → `BackendVendor`
- `getRetailerOrders(retailerId: string)` → order list

**Create `src/features/retailers/api/retailer-queries.ts`:**
Query key factory + hooks:
- `retailerKeys.all`, `retailerKeys.lists()`, `retailerKeys.list(params)`, `retailerKeys.details()`, `retailerKeys.detail(id)`
- `useRetailersQuery(params)` — list with pagination meta
- `useRetailerQuery(retailerId)` — single retailer detail
- `useRetailerOrdersQuery(retailerId)` — orders

All hooks apply `toRetailerViewModel` transform in `select` where applicable.

### Task 3: Create retailer list page

**Create `src/features/retailers/components/RetailerListPage.tsx`:**

- PageHeader: "Retailers" with description "Manage retailer accounts"
- Search input (debounced 300ms) that maps to `name` API param
- Category filter dropdown (if categories are known; otherwise just search)
- DataTable with columns: Name (logo + store name), Email, Phone, Category, Status, Created
- Name column: logo thumbnail + store name, clickable → `/retailers/$retailerId`
- Email/Phone columns: show with CopyButton on hover
- Status column: StatusBadge (derived from isActive/isOnline)
- Pagination: server-side via useTableParams

**Update `src/app/routes/_authenticated/retailers/index.tsx`:**
Replace placeholder with `<RetailerListPage />`.

### Task 4: Create retailer detail page with tabs

**Create route: `src/app/routes/_authenticated/retailers/$retailerId.tsx`:**
- File-based route for `/retailers/:retailerId`

**Create `src/features/retailers/components/RetailerDetailPage.tsx`:**
- EntityDetailHeader with store name, email, logo, status
- Tabs: Overview | Orders | Notes

**Create tab components:**
- `RetailerOverviewTab.tsx` — Card grid: Contact Info (email, phone, address with CopyableField), Business Details (ID with CopyableField, category, commission %, Stripe account, store URL, online status, opening hours), Dates (created, updated)
- `RetailerOrdersTab.tsx` — Mini DataTable of retailer's orders (ID, customer, status, total, date). Empty state if none.
- `RetailerNotesTab.tsx` — Placeholder with EmptyState ("Notes will be available in Phase 4")

### Task 5: Wire up route and verify build

- Ensure `$retailerId.tsx` route is picked up by TanStack Router
- Run `npm run build` to verify no TypeScript errors
- Verify route tree includes both `/retailers/` and `/retailers/$retailerId`

## Commits

Single commit: `feat(02-03): retailer list page, detail page with tabs, API layer`

## Success Criteria

- [ ] Retailer list page shows paginated DataTable with search
- [ ] Clicking a retailer row navigates to `/retailers/:retailerId`
- [ ] Retailer detail page shows EntityDetailHeader + 3 tabs
- [ ] Overview tab shows retailer info with copyable fields
- [ ] Orders tab shows data or empty state
- [ ] Notes tab shows Phase 4 placeholder
- [ ] Backend "vendor" → frontend "retailer" mapping is clean
- [ ] All types are strict (no `any`, no `as any`)
- [ ] `npm run build` passes
