---
phase: 05-power-features
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/shared/EditableField.tsx
  - src/features/users/api/user-api.ts
  - src/features/users/api/user-queries.ts
  - src/features/users/components/UserOverviewTab.tsx
  - src/features/users/components/UserDetailPage.tsx
  - src/features/retailers/api/retailer-api.ts
  - src/features/retailers/api/retailer-queries.ts
  - src/features/retailers/components/RetailerOverviewTab.tsx
  - src/features/retailers/components/RetailerDetailPage.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can click a user field (email, phone, language) to edit it inline"
    - "Admin can click a retailer field (email, phone, store URL, description) to edit it inline"
    - "Admin can toggle retailer online/offline status from the detail page"
    - "Edits are saved via PATCH API calls and the UI updates immediately"
    - "Failed edits show error toast and revert to previous value"
  artifacts:
    - path: "src/components/shared/EditableField.tsx"
      provides: "Reusable inline edit component"
      min_lines: 40
    - path: "src/features/users/api/user-api.ts"
      provides: "updateUser PATCH function"
      contains: "admin/users"
    - path: "src/features/retailers/api/retailer-api.ts"
      provides: "updateRetailer PATCH function"
      contains: "admin/vendors"
  key_links:
    - from: "UserOverviewTab"
      to: "updateUser API"
      via: "useUpdateUserMutation"
      pattern: "useUpdateUser"
    - from: "RetailerOverviewTab"
      to: "updateRetailer API"
      via: "useUpdateRetailerMutation"
      pattern: "useUpdateRetailer"
    - from: "EditableField"
      to: "onSave callback"
      via: "props.onSave"
      pattern: "onSave"
---

<objective>
Enable inline editing of entity fields and quick actions on detail pages (DETL-08 + DETL-09).

Purpose: Admins can fix user contact info, update retailer details, and toggle retailer status directly from detail pages instead of needing to go to the backend database. This eliminates the most common "I need to ask the developer" support friction.

Output: EditableField shared component, user/retailer mutation hooks, updated overview tabs with inline edit, retailer online toggle quick action.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/features/users/components/UserOverviewTab.tsx
@src/features/users/types.ts
@src/features/users/api/user-api.ts
@src/features/users/api/user-queries.ts
@src/features/retailers/components/RetailerOverviewTab.tsx
@src/features/retailers/components/RetailerDetailPage.tsx
@src/features/retailers/types.ts
@src/features/retailers/api/retailer-api.ts
@src/features/retailers/api/retailer-queries.ts
@src/lib/api-client.ts
@src/components/shared/CopyableField.tsx
@src/features/notes/api/notes-queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EditableField component and mutation API functions</name>
  <files>src/components/shared/EditableField.tsx, src/features/users/api/user-api.ts, src/features/users/api/user-queries.ts, src/features/retailers/api/retailer-api.ts, src/features/retailers/api/retailer-queries.ts</files>
  <action>
    **EditableField component** (`src/components/shared/EditableField.tsx`):
    Create a component that shows a value as read-only text (like CopyableField) with a pencil icon on hover. On click, switches to an input field. Enter saves, Escape cancels.

    Props:
    ```
    label: string
    value: string
    onSave: (newValue: string) => Promise<void>  // async to handle API call
    mono?: boolean
    disabled?: boolean
    ```

    Behavior:
    - Default state: renders label + value (same layout as CopyableField) with a Pencil icon on hover
    - Editing state: renders label + Input + Save/Cancel icon buttons
    - While saving: shows spinner on the save button, input disabled
    - On success: reverts to read-only, shows sonner toast "Field updated"
    - On error: reverts to read-only with previous value, shows sonner error toast
    - Escape key cancels, Enter key saves
    - Use shadcn Input component for the edit field

    **User mutation API** (`src/features/users/api/user-api.ts`):
    Add `updateUser(userId: string, data: Partial<UpdateUserPayload>)` that calls `api.patch('admin/users/${userId}', data)`.

    Add `UpdateUserPayload` type to user types: `{ firstName?: string; lastName?: string; email?: string; phone?: string; language?: string }`.

    **User mutation hook** (`src/features/users/api/user-queries.ts`):
    Add `useUpdateUserMutation(userId: string)` following the same pattern as `useCreateNoteMutation` in notes-queries.ts. On success, invalidate `userKeys.detail(userId)` to refetch user data.

    **Retailer mutation API** (`src/features/retailers/api/retailer-api.ts`):
    Add `updateRetailer(retailerId: string, data: Partial<UpdateRetailerPayload>)` that calls `api.patch('admin/vendors/${retailerId}', data)`.

    Add `UpdateRetailerPayload` type to retailer types: `{ storeName?: string; email?: string; phone?: string; storeUrl?: string; description?: string; isOnline?: boolean; vendorCategory?: string; address?: string }`.

    **Retailer mutation hook** (`src/features/retailers/api/retailer-queries.ts`):
    Add `useUpdateRetailerMutation(retailerId: string)` — invalidate `retailerKeys.detail(retailerId)` on success.

    Reference `src/features/notes/api/notes-queries.ts` for the mutation + invalidation pattern.
  </action>
  <verify>npm run build succeeds; EditableField component exported; mutation functions and hooks compile</verify>
  <done>EditableField component created; updateUser and updateRetailer API functions exist; mutation hooks wired with query invalidation</done>
</task>

<task type="auto">
  <name>Task 2: Wire inline editing into UserOverviewTab and RetailerOverviewTab</name>
  <files>src/features/users/components/UserOverviewTab.tsx, src/features/users/components/UserDetailPage.tsx, src/features/retailers/components/RetailerOverviewTab.tsx, src/features/retailers/components/RetailerDetailPage.tsx</files>
  <action>
    **UserOverviewTab** — Replace CopyableField for editable fields with EditableField:
    - Email: EditableField with `onSave` calling `updateUserMutation.mutateAsync({ email: newValue })`
    - Phone: EditableField with `onSave` calling `updateUserMutation.mutateAsync({ phone: newValue })`
    - Language: EditableField (if present) with `onSave` calling `updateUserMutation.mutateAsync({ language: newValue })`
    - Keep User ID, Role, SSO Provider, Created, Updated as read-only CopyableField/static text (not editable)
    - Keep Test Account and Anonymized badges as-is

    Pass `useUpdateUserMutation(user.id)` into UserOverviewTab. Either:
    (a) Call the hook inside UserOverviewTab directly (simpler), or
    (b) Pass mutation via prop from UserDetailPage

    Prefer (a) — call the hook inside UserOverviewTab. The component receives `user.id` from the `user` prop.

    **RetailerOverviewTab** — Replace CopyableField for editable fields with EditableField:
    - Email: EditableField
    - Phone: EditableField
    - Address: EditableField
    - Store URL: EditableField
    - Description: EditableField (use textarea variant or multi-line — for simplicity, use single-line input; description can be a slightly taller input or just accept single-line for now)
    - Keep ID, Category, Commission, Stripe Account, Dates as read-only

    **Retailer online toggle quick action** — In RetailerDetailPage or RetailerOverviewTab:
    Add a Switch or Button in the Online Status area that toggles `isOnline` via `updateRetailerMutation.mutateAsync({ isOnline: !retailer.isOnline })`. Use a shadcn Switch component next to the Online Status StatusBadge. On toggle, the mutation fires and query invalidation refreshes the status.

    Note: The backend PATCH endpoint for vendors accepts `isOnline: boolean`. The frontend derives status from `isActive && isOnline`. Since we can't change `isActive` via admin, the toggle only controls `isOnline`.

    **Important backend field mapping**: The backend uses `storeName` (not `name`), `vendorCategory` (not `category`). Make sure the PATCH payload uses backend field names, not the frontend ViewModel names. The transform layer handles backend -> frontend naming; the mutation must reverse this.
  </action>
  <verify>npm run build succeeds; UserOverviewTab shows pencil icons on editable fields; RetailerOverviewTab shows pencil icons and online toggle</verify>
  <done>User email/phone/language are inline-editable; retailer email/phone/address/storeUrl/description are inline-editable; retailer online status is toggleable; all edits call PATCH API and refresh data via query invalidation</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] EditableField component works: hover shows pencil, click enters edit mode, Enter saves, Escape cancels
- [ ] User email inline edit: change value, Enter, toast appears, field updates
- [ ] User phone inline edit works
- [ ] Retailer email, phone, address, store URL inline edit works
- [ ] Retailer online toggle: switch flips, mutation fires, status badge updates
- [ ] Failed mutations show error toast and revert
- [ ] Non-editable fields (IDs, dates, role) remain read-only
- [ ] No TypeScript errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- EditableField is reusable across any entity
- DETL-08 partially satisfied (online toggle quick action; user block not possible without backend endpoint)
- DETL-09 partially satisfied (editable fields that have PATCH endpoints; non-mutable fields stay read-only)
</success_criteria>

<output>
After completion, create `.planning/phases/05-power-features/05-02-SUMMARY.md`
</output>
